local VoraLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/juansyahrz17-prog/vorahub/refs/heads/main/lib.lua"))()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Stats = game:GetService("Stats")
local CoreGui = game:GetService("CoreGui")
local VirtualUser = game:GetService("VirtualUser")
local VirtualInputManager = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local Knit = ReplicatedStorage:WaitForChild("common"):WaitForChild("packages"):WaitForChild("Knit"):WaitForChild("Services")
local KnitServices = {
	BackpackService = Knit:WaitForChild("BackpackService"),
	MinigameService = Knit:WaitForChild("MinigameService"),
	HarpoonService = Knit:WaitForChild("HarpoonService"),
	FishService = Knit:WaitForChild("FishService"),
	SellService = Knit:WaitForChild("SellService"),
	PurchaseService = Knit:WaitForChild("PurchaseService"),
	RaceService = Knit:WaitForChild("RaceService"),
	InventoryService = Knit:WaitForChild("InventoryService"),
}

local KnitCtrl = require(ReplicatedStorage.common.packages.Knit)
local FishController = KnitCtrl.GetController("FishController")
local Replica = KnitCtrl.GetController("DataController"):GetReplica()
task.wait(1)

local Remotes = {
	Equip = KnitServices.BackpackService:WaitForChild("RF"):WaitForChild("Equip"),
	Favorite = KnitServices.BackpackService:WaitForChild("RF"):WaitForChild("Favorite"),
	UpdateMinigame = KnitServices.MinigameService:WaitForChild("RF"):WaitForChild("Update"),
	CancelMinigame = KnitServices.MinigameService:WaitForChild("RF"):WaitForChild("CancelMinigame"),
	StartCatching = KnitServices.HarpoonService:WaitForChild("RF"):WaitForChild("StartCatching"),
	CollectFish = KnitServices.FishService:WaitForChild("RF"):WaitForChild("CollectFish"),
	SellInventory = KnitServices.SellService:WaitForChild("RF"):WaitForChild("SellInventory"),
	BuyItem = KnitServices.PurchaseService:WaitForChild("RF"):WaitForChild("BuyItem"),
	Reroll = KnitServices.RaceService:WaitForChild("RF"):WaitForChild("Reroll"),
	EquipItem = KnitServices.InventoryService:WaitForChild("RF"):WaitForChild("EquipItem"),
	UnlockChest = Knit:WaitForChild("ChestService"):WaitForChild("RF"):WaitForChild("UnlockChest"),
}

local CM = require(ReplicatedStorage.common.lib.modules.CatchingMinigame)
local _new = CM.new
CM.new = function(c, cfg)
	local i = _new(c, cfg)
	i.controlBarScale = 5
	i.progressGravity = 0
	return i
end

local Assets = {
	Fish = ReplicatedStorage.common.assets.fish,
	Guns = ReplicatedStorage.common.assets.guns,
	Tube = ReplicatedStorage.common.assets.tubes,
}

local FishList = (function()
	local names = {}
	for _, v in ipairs(Assets.Fish:GetChildren()) do
		if v.Name ~= "fish_loot" then
			if v:IsA("Model") then
				table.insert(names, v.Name)
			elseif v:IsA("Folder") then
				for _, m in ipairs(v:GetChildren()) do
					if m:IsA("Model") then table.insert(names, m.Name) end
				end
			end
		end
	end
	table.sort(names, function(a, b) return a:lower() < b:lower() end)
	return names
end)()

local GunList = (function()
	local names = {}
	for _, v in ipairs(Assets.Guns:GetChildren()) do
		if v:IsA("Model") or v:IsA("Folder") then table.insert(names, v.Name) end
	end
	table.sort(names, function(a, b) return a:lower() < b:lower() end)
	return names
end)()

local TubeList = (function()
	local names = {}
	for _, v in ipairs(Assets.Tube:GetChildren()) do
		if v:IsA("Model") or v:IsA("Folder") then table.insert(names, v.Name) end
	end
	table.sort(names, function(a, b) return a:lower() < b:lower() end)
	return names
end)()

local MutationList = (function()
	local names = {}
	for _, m in ipairs(ReplicatedStorage.common.presets.fish.mutations:GetChildren()) do
		table.insert(names, m.Name)
	end
	table.sort(names)
	return names
end)()

local RarityModule = require(ReplicatedStorage.common.presets.rarity)

local RarityList = (function()
	local names = {}
	for name in pairs(RarityModule) do
		table.insert(names, name)
	end
	table.sort(names, function(a, b) return RarityModule[a].index < RarityModule[b].index end)
	return names
end)()

local _rarityCache = {}
local function getFishRarity(name)
	if _rarityCache[name] then return _rarityCache[name] end
	for _, folder in ipairs(ReplicatedStorage.common.presets.items.fish:GetChildren()) do
		local m = folder:FindFirstChild(name)
		if m then
			_rarityCache[name] = require(m).rarity
			return _rarityCache[name]
		end
	end
end

local LocFarm = {
	["Ancient Sands"] = CFrame.new(-1466, 4567, 60),
	["Forgotten Deep"] = CFrame.new(-471, 4855, -212),
	["Spirit Roots"] = CFrame.new(1697, 4183, -1885),
}

local OxygenCordinat = {
	CFrame.new(120, 4883, 15),
	CFrame.new(-3, 4883, 122),
	CFrame.new(-124, 4883, -10),
	CFrame.new(-4, 4883, -125),
}

local SellCordinat = {
	CFrame.new(120, 4883, 15),
	CFrame.new(-3, 4883, 122),
	CFrame.new(-124, 4883, -10),
	CFrame.new(-4, 4883, -125),
}

local st = {
	SelectedMutations = {},
	SelectRarity = {},
	TweenTime = 0.3,
	MaxRange = 25,
	AutoEquipGun = false,
	SelectFish = {},
	SelectMutation = {},
	SelectFavRarity = {},
	StrictMode = false,
	FavRunning = false,
	IsUnfavoriting = false,
	SelectedGun = nil,
	SelectedTube = nil,
	Monitor = nil,
	MonitorConns = {},
	WebhookURL = "",
	WebhookRarity = {},
	WebhookRunning = false,
	WebhookStatsURL = "",
	WebhookStatsEnabled = false,
	WebhookStatsMessageId = nil,
	ESPEnabled = false,
	ESPFilterRarity = {},
	ESPFilterFish = {},
	ESPFilterMutation = {},
	ESPConnection = nil,
	ESPBillboards = {},
	AutoRespawn = false,
	AutoRespawnToken = 0,
	LowGraphics = false,
	ExtremeGraphics = false,
	AutoFarm = false,
	SelectedFarm = nil,
	CurrentTween = nil,
	IsTweening = false,
	IsBusy = false,
	IsGoingSafe = false,
	InstantCatch = false,
	AutoSell = false,
	IsSelling = false,
	SellAt = "90%",
	AutoRefillOxygen = false,
	Priority1 = {},
	Priority2 = {},
	Priority3 = {},
	AutoTreasure = false,
	SelectedTier = "Tier 1",
	TreasureRunning = false,
	ChestBlacklist = {},
	ChestsFarmed = 0,
	HideIdentifier = false,
	FakeName = "",
	FakeLevel = "",
	EquipGunName = nil,
	EquipTubeName = nil,
	NoclipEnabled = true,
}

local _thread, _favConnection, _webhookConnection, _statsWebhookLoop = nil, nil, nil, nil
local _caughtListener = nil
local function has(tbl, val) return tbl[val] or table.find(tbl, val) end

local function SetNoclip(enabled)
	local char = LocalPlayer.Character
	if not char then return end
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = not enabled
		end
	end
end

local function DisableAllCollisions()
	local char = LocalPlayer.Character
	if not char then return end
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
		end
	end
end

RunService.Stepped:Connect(function()
	if st.NoclipEnabled or st.IsTweening or st.AutoFarm then
		SetNoclip(true)
		DisableAllCollisions()
	end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
	task.wait(0.5)
	if st.NoclipEnabled or st.AutoFarm then
		for _, part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end
	char.DescendantAdded:Connect(function(desc)
		if (st.NoclipEnabled or st.AutoFarm) and desc:IsA("BasePart") then
			desc.CanCollide = false
		end
	end)
end)

local function CancelCurrentTween()
	if st.CurrentTween then
		st.CurrentTween:Cancel()
		st.CurrentTween = nil
	end
	st.IsTweening = false
end

local function TweenTo(cf)
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	CancelCurrentTween()
	st.IsTweening = true
	local time = math.max(tonumber(st.TweenTime) or 0.1, 0.05)
	local tween = TweenService:Create(hrp, TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), { CFrame = cf })
	st.CurrentTween = tween
	tween:Play()
	tween.Completed:Once(function()
		if st.CurrentTween == tween then
			st.IsTweening = false
		end
	end)
end

local function TweenToWithSpeed(cf, speed)
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	CancelCurrentTween()
	st.IsTweening = true
	local distance = (hrp.Position - cf.Position).Magnitude
	local time = math.max(distance / speed, 0.05)
	local tween = TweenService:Create(hrp, TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), { CFrame = cf })
	st.CurrentTween = tween
	tween:Play()
end

local function TweenToAndWait(cf, speed)
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end
	CancelCurrentTween()
	st.IsTweening = true
	local spd = speed or 500
	local dist = (hrp.Position - cf.Position).Magnitude
	local time = math.max(dist / math.max(spd, 0.01), 0.05)
	local tween = TweenService:Create(hrp, TweenInfo.new(time, Enum.EasingStyle.Linear), { CFrame = cf })
	st.CurrentTween = tween
	tween:Play()
	tween.Completed:Wait()
	while (hrp.Position - cf.Position).Magnitude > 3 do task.wait(0.001) end
	st.CurrentTween = nil
	st.IsTweening = false
	return true
end

local function GetEquippedTubeMaxOxygen()
	local ok, result = pcall(function()
		local scroll = PlayerGui.Main.TopLeft.Menus.Inventory.Frame.Scroll_Tubes
		for _, tube in ipairs(scroll:GetChildren()) do
			local eq = tube:FindFirstChild("Equipped")
			if eq and eq.Visible then
				local lbl = tube.StatList.oxygen.TextLabel
				return tonumber(lbl.Text:match("[%d%.]+"))
			end
		end
	end)
	return ok and result or nil
end

local function GetCurrentOxygen()
	local ok, result = pcall(function()
		local lbl = PlayerGui.Main.Oxygen.CanvasGroup:FindFirstChild("Oxygen")
		return lbl and tonumber(lbl.Text)
	end)
	return ok and result or nil
end

local function GetCurrentWeight()
	local ok, result = pcall(function()
		local lbl = PlayerGui.Main.Oxygen.RightStats.Frame.Weight:FindFirstChild("Wght")
		return lbl and tonumber(lbl.Text) or 0
	end)
	return ok and result or 0
end

local function GetMaxWeight()
	local ok, result = pcall(function()
		local lbl = PlayerGui.Main.Oxygen.RightStats.Frame.Weight:FindFirstChild("Max")
		if not lbl then return 0 end
		local n = lbl.Text:match("[%d%.]+")
		return tonumber(n) or 0
	end)
	return ok and result or 0
end

local function GetPlayerCash()
	local ok, result = pcall(function()
		local leaderstats = LocalPlayer:FindFirstChild("leaderstats")
		if leaderstats then
			local cash = leaderstats:FindFirstChild("Cash")
			if cash then return tostring(cash.Value) end
		end
		return "0"
	end)
	return ok and result or "0"
end

local function GetPlayerLevel()
	local ok, result = pcall(function()
		local leaderstats = LocalPlayer:FindFirstChild("leaderstats")
		if leaderstats then
			local level = leaderstats:FindFirstChild("Level")
			if level then return tostring(level.Value) end
		end
		return "1"
	end)
	return ok and result or "1"
end

local function GetCurrentLocation()
	if st.SelectedFarm then return st.SelectedFarm end
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return "Unknown" end
	local minDist = math.huge
	local closestLoc = "Unknown"
	for name, cf in pairs(LocFarm) do
		local dist = (hrp.Position - cf.Position).Magnitude
		if dist < minDist then minDist = dist; closestLoc = name end
	end
	if minDist < 500 then return closestLoc end
	return "Roaming"
end

local function GetPlayerStatus()
	if st.IsSelling then return "Selling Fish"
	elseif st.IsGoingSafe then return "Refilling Oxygen"
	elseif st.AutoFarm then return "Auto Farming"
	else return "Idle" end
end

local function GetSellThreshold()
	local max = GetMaxWeight()
	if st.SellAt == "max" then return max end
	local num = tonumber(st.SellAt)
	if num then return num end
	local percent = tonumber((st.SellAt or ""):match("(%d+)%s*%%"))
	if percent then return max * (percent / 100) end
	return max * 0.9
end

local function GetNearestOxygenCFrame()
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end
	local best, dist = nil, math.huge
	for _, cf in ipairs(OxygenCordinat) do
		local d = (hrp.Position - cf.Position).Magnitude
		if d < dist then dist, best = d, cf end
	end
	return best
end

local function GetNearestSellCFrame()
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end
	local nearest, dist = nil, math.huge
	for _, cf in ipairs(SellCordinat) do
		local d = (hrp.Position - cf.Position).Magnitude
		if d < dist then dist = d; nearest = cf end
	end
	return nearest
end

local function GetReturnFarmCFrame()
	if st.SelectedFarm then return LocFarm[st.SelectedFarm] end
	return nil
end

local function GetFishInfoFromModel(fishModel)
	local head = fishModel:FindFirstChild("Head")
	if not head then return nil end
	local stats = head:FindFirstChild("stats")
	if not stats then return nil end
	local fishLabel = stats:FindFirstChild("Fish")
	if not fishLabel then return nil end
	local name = fishLabel.Text
	local root = fishModel:FindFirstChild("RootPart")
	if not root then return nil end
	if root:FindFirstChild("block") then return nil end
	local mutations = {}
	local mutLabel = stats:FindFirstChild("Mutation")
	if mutLabel and mutLabel.Text and mutLabel.Text ~= "" then
		for m in mutLabel.Text:gmatch("[^,]+") do
			table.insert(mutations, m:match("^%s*(.-)%s*$"))
		end
	end
	return { name = name, mutations = mutations, root = root, cframe = root.CFrame }
end

local function findTarget()
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local pos = hrp.Position

	local cacheHasData = false
	if FishController and FishController.fish_cache then
		for _ in pairs(FishController.fish_cache) do
			cacheHasData = true
			break
		end
	end

	if cacheHasData then
		local function nearest(filter)
			local best, bd
			for id, f in pairs(FishController.fish_cache) do
				if not f.dead and f.health > 0 and filter(f) then
					local fishPos = f.cframe.Position
					if st.SelectedFarm then
						local farmCF = LocFarm[st.SelectedFarm]
						if farmCF and (fishPos - farmCF.Position).Magnitude > 350 then continue end
					end
					local d = (fishPos - pos).Magnitude
					if not bd or d < bd then
						best, bd = { id = id, pos = fishPos, cframe = f.cframe, source = "cache" }, d
					end
				end
			end
			return best
		end

		if next(st.SelectedMutations) then
			local t = nearest(function(f)
				for _, m in ipairs(f.mutations) do
					if has(st.SelectedMutations, m) then return true end
				end
			end)
			if t then return t end
		end
		for _, list in ipairs({ st.Priority1, st.Priority2, st.Priority3 }) do
			if next(list) then
				local t = nearest(function(f) return has(list, f.name) end)
				if t then return t end
			end
		end
		if next(st.SelectRarity) then
			local t = nearest(function(f)
				local r = getFishRarity(f.name)
				return r and has(st.SelectRarity, r)
			end)
			if t then return t end
		end
	end

	local fishClient = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Fish") and workspace.Game.Fish:FindFirstChild("client")
	if not fishClient then return nil end

	local function nearestWS(filter)
		local best, bd
		for _, fishModel in ipairs(fishClient:GetChildren()) do
			local info = GetFishInfoFromModel(fishModel)
			if not info then continue end
			if not filter(info) then continue end
			local fishPos = info.cframe.Position
			if st.SelectedFarm then
				local farmCF = LocFarm[st.SelectedFarm]
				if farmCF and (fishPos - farmCF.Position).Magnitude > 350 then continue end
			end
			local d = (fishPos - pos).Magnitude
			if not bd or d < bd then
				best, bd = { id = fishModel.Name, pos = fishPos, cframe = info.cframe, source = "workspace" }, d
			end
		end
		return best
	end

	if next(st.SelectedMutations) then
		local t = nearestWS(function(info)
			for _, m in ipairs(info.mutations) do
				if has(st.SelectedMutations, m) then return true end
			end
		end)
		if t then return t end
	end
	for _, list in ipairs({ st.Priority1, st.Priority2, st.Priority3 }) do
		if next(list) then
			local t = nearestWS(function(info) return has(list, info.name) end)
			if t then return t end
		end
	end
	if next(st.SelectRarity) then
		local t = nearestWS(function(info)
			local r = getFishRarity(info.name)
			return r and has(st.SelectRarity, r)
		end)
		if t then return t end
	end

	return nil
end

local function HandleOxygenRefill()
	if st.IsGoingSafe or not st.AutoRefillOxygen then return end
	local ok, low = pcall(function()
		return PlayerGui.Main.Backpack.Folder.LowOxygen
	end)
	if not (ok and low and low.Visible) then return end

	st.IsGoingSafe = true
	st.IsBusy = true
	CancelCurrentTween()

	local maxOxy = GetEquippedTubeMaxOxygen()
	if not maxOxy then
		st.IsGoingSafe = false
		st.IsBusy = false
		return
	end

	local cf = GetNearestOxygenCFrame()
	if not cf then
		st.IsGoingSafe = false
		st.IsBusy = false
		return
	end

	TweenToWithSpeed(cf, 500)
	if st.CurrentTween then st.CurrentTween.Completed:Wait() end
	st.CurrentTween = nil
	st.IsTweening = false

	while st.AutoFarm do
		local cur = GetCurrentOxygen()
		if cur and cur >= maxOxy then break end
		task.wait(0.1)
	end

	local returnCF = GetReturnFarmCFrame()
	if returnCF and st.SelectedFarm ~= "Forgotten Deep" then
		TweenToWithSpeed(returnCF, 500)
		if st.CurrentTween then st.CurrentTween.Completed:Wait() end
		st.CurrentTween = nil
		st.IsTweening = false
	end

	st.IsGoingSafe = false
	st.IsBusy = false
end

local function HandleSell()
	if st.IsSelling then return end
	local current = GetCurrentWeight()
	local threshold = GetSellThreshold()
	if threshold <= 0 or current < threshold then return end

	st.IsSelling = true
	st.IsBusy = true
	CancelCurrentTween()

	local cf = GetNearestSellCFrame()
	if cf then
		TweenToAndWait(cf, 500)
		task.wait(0.5)
		while st.AutoSell do
			local before = GetCurrentWeight()
			pcall(function() Remotes.SellInventory:InvokeServer() end)
			task.wait(0.3)
			local now = GetCurrentWeight()
			if now < threshold then break end
			if now >= before then task.wait(0.3) end
		end
	end

	local returnCF = GetReturnFarmCFrame()
	if returnCF and st.SelectedFarm ~= "Forgotten Deep" then
		TweenToAndWait(returnCF, 500)
	end

	st.IsSelling = false
	st.IsBusy = false
end

local function StartAutoFarm()
	if st.AutoFarm then return end
	st.AutoFarm = true

	if st.SelectedFarm and st.SelectedFarm ~= "Forgotten Deep" then
		local farmCF = LocFarm[st.SelectedFarm]
		if farmCF then
			TweenToAndWait(farmCF, 500)
		end
	end

	_thread = task.spawn(function()
		while st.AutoFarm do
			if LocalPlayer:GetAttribute("catching") then
				repeat task.wait(0.1) until not LocalPlayer:GetAttribute("catching") or not st.AutoFarm
				task.wait(0.2)
				continue
			end

			if st.IsBusy then
				repeat task.wait(0.1) until not st.IsBusy or not st.AutoFarm
				task.wait(0.2)
				if not st.AutoFarm then break end
				continue
			end

			if st.AutoRefillOxygen then
				local ok, low = pcall(function()
					return PlayerGui.Main.Backpack.Folder.LowOxygen
				end)
				if ok and low and low.Visible then
					HandleOxygenRefill()
					task.wait(0.2)
					continue
				end
			end

			if st.AutoSell then
				local current = GetCurrentWeight()
				local threshold = GetSellThreshold()
				if threshold > 0 and current >= threshold then
					HandleSell()
					task.wait(0.2)
					continue
				end
			end

			local target = findTarget()
			if target then
				if st.IsBusy then
					task.wait(0.1)
					continue
				end
				local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
				if not hrp then
					task.wait(0.1)
					continue
				end
				local dist = (hrp.Position - target.pos).Magnitude
				if dist > st.MaxRange then
					TweenTo(target.cframe)
					task.wait(0.05)
					continue
				end

				CancelCurrentTween()

				local success = pcall(function()
					Remotes.StartCatching:InvokeServer(target.id)
				end)

				if success then
					pcall(function() Remotes.CollectFish:InvokeServer(target.id) end)

					if st.InstantCatch then
						task.wait(0.8)
						if st.AutoFarm and LocalPlayer:GetAttribute("catching") then
							pcall(function()
								Remotes.UpdateMinigame:InvokeServer("ProgressUpdate", { progress = 1, rewards = {} })
							end)
						end
					end

					if LocalPlayer:GetAttribute("catching") then
						repeat task.wait(0.1) until not LocalPlayer:GetAttribute("catching") or not st.AutoFarm
					end

					task.wait(0.2)
				else
					task.wait(0.3)
				end

				task.wait(0.1)
			else
				task.wait(0.3)
			end
		end
	end)
end

local function StopAutoFarm()
	st.AutoFarm = false
	st.IsBusy = false
	st.IsSelling = false
	st.IsGoingSafe = false
	CancelCurrentTween()
	if _thread then task.cancel(_thread); _thread = nil end
end

local function shouldFavorite(item)
	if item.class ~= "fish" or item.favorited then return false end
	local fishMatch = next(st.SelectFish) and has(st.SelectFish, item.name)
	local mutMatch = false
	if next(st.SelectMutation) then
		for _, m in ipairs(item.mutations or {}) do
			if has(st.SelectMutation, m) then mutMatch = true; break end
		end
	end
	local rarityMatch = next(st.SelectFavRarity) and has(st.SelectFavRarity, getFishRarity(item.name))
	if st.StrictMode then return fishMatch and mutMatch and rarityMatch end
	return fishMatch or mutMatch or rarityMatch
end

local function scanInventory()
	for uuid, item in pairs(Replica.Data.inventory) do
		if shouldFavorite(item) then
			Remotes.Favorite:InvokeServer(uuid)
			task.wait(2)
		end
	end
end

local function StartFavorite()
	if st.FavRunning then return end
	st.FavRunning = true
	local Notifications = PlayerGui:WaitForChild("Top"):WaitForChild("Notifications")
	_favConnection = Notifications.ChildAdded:Connect(function(child)
		if not st.FavRunning then return end
		local label = child:FindFirstChild("Frame") and child.Frame:FindFirstChild("Label")
		if label and string.find(label.Text, "Caught") then
			task.spawn(function() task.wait(1); scanInventory() end)
		end
	end)
	task.spawn(scanInventory)
end

local function StopFavorite()
	st.FavRunning = false
	if _favConnection then _favConnection:Disconnect(); _favConnection = nil end
end

local function UnfavoriteAll()
	st.IsUnfavoriting = true
	task.spawn(function()
		for uuid, item in pairs(Replica.Data.inventory) do
			if not st.IsUnfavoriting then break end
			if item.class == "fish" and item.favorited then
				Remotes.Favorite:InvokeServer(uuid)
				task.wait(1)
			end
		end
		st.IsUnfavoriting = false
	end)
end

local function StopUnfavorite() st.IsUnfavoriting = false end

local function parseNotif(child)
	local fullName, weight
	for _, desc in ipairs(child:GetDescendants()) do
		if desc:IsA("TextLabel") then
			local clean = desc.Text:gsub("<.->", "")
			local n = string.match(clean, "Caught a (.+) weighing")
			if n then fullName = n end
			local w = string.match(clean, "([%d%.]+)kg")
			if w then weight = w .. " kg" end
		end
	end
	if not fullName then return end
	local name = fullName
	local mutation = nil
	if not getFishRarity(name) then
		local mut, fish = string.match(name, "^(%S+)%s+(.+)$")
		if fish and getFishRarity(fish) then mutation = mut; name = fish end
	end
	return name, weight or "?", mutation
end

local function WebhookSend(name, rarity, weight)
	local c = RarityModule[rarity] and RarityModule[rarity].color
	local color = c and math.floor(c.R * 255) * 65536 + math.floor(c.G * 255) * 256 + math.floor(c.B * 255) or 5814783
	local req = request or http_request or (syn and syn.request)
	if not req then return end
	local iconUrl = "https://cdn.discordapp.com/attachments/1458820220339753084/1470950568846561434/IMG-20260207-WA0026.jpg"
	pcall(req, {
		Url = st.WebhookURL,
		Method = "POST",
		Headers = { ["Content-Type"] = "application/json" },
		Body = HttpService:JSONEncode({
			username = "VoraHUB Abyss",
			avatar_url = iconUrl,
			embeds = {{
				title = "Fish Caught!",
				description = "**" .. name .. "** has been caught!",
				color = color,
				fields = {
					{ name = "Fish Name", value = "```" .. name .. "```", inline = true },
					{ name = "Rarity", value = "```" .. rarity .. "```", inline = true },
					{ name = "Weight", value = "```" .. weight .. "```", inline = true },
				},
				thumbnail = { url = iconUrl },
				footer = { text = "VoraHUB", icon_url = iconUrl },
				timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
			}},
		}),
	})
end

local function SendStatsWebhook()
	if st.WebhookStatsURL == "" then return end
	local req = request or http_request or (syn and syn.request)
	if not req then return end
	local playerName = LocalPlayer.Name
	local cash = GetPlayerCash()
	local level = GetPlayerLevel()
	local status = GetPlayerStatus()
	local location = GetCurrentLocation()
	local weight = GetCurrentWeight()
	local maxWeight = GetMaxWeight()
	local oxygen = GetCurrentOxygen() or 0
	local maxOxygen = GetEquippedTubeMaxOxygen() or 100
	local statusColor = 3447003
	if status:find("Farming") then statusColor = 3066993
	elseif status:find("Selling") then statusColor = 15844367
	elseif status:find("Refilling") then statusColor = 5793266 end
	local iconUrl = "https://cdn.discordapp.com/attachments/1458820220339753084/1470950568846561434/IMG-20260207-WA0026.jpg"
	local embedData = {
		title = "Player Statistics - " .. playerName,
		description = "**Real-time farming statistics**",
		color = statusColor,
		fields = {
			{ name = "Player", value = "```" .. playerName .. "```", inline = true },
			{ name = "Level", value = "```" .. level .. "```", inline = true },
			{ name = "Cash", value = "```$" .. cash .. "```", inline = true },
			{ name = "Status", value = status, inline = false },
			{ name = "Location", value = "```" .. location .. "```", inline = true },
			{ name = "Weight", value = "```" .. weight .. " / " .. maxWeight .. " kg```", inline = true },
			{ name = "Oxygen", value = "```" .. math.floor(oxygen) .. " / " .. math.floor(maxOxygen) .. "```", inline = true },
		},
		thumbnail = { url = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. LocalPlayer.UserId .. "&width=420&height=420&format=png" },
		footer = { text = "VoraHUB Auto-Update", icon_url = iconUrl },
		timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
	}
	local webhookBody = { username = "VoraHUB Statistics", avatar_url = iconUrl, embeds = { embedData } }
	if st.WebhookStatsMessageId then
		pcall(req, {
			Url = st.WebhookStatsURL .. "/messages/" .. st.WebhookStatsMessageId,
			Method = "PATCH",
			Headers = { ["Content-Type"] = "application/json" },
			Body = HttpService:JSONEncode(webhookBody),
		})
	else
		local success, response = pcall(req, {
			Url = st.WebhookStatsURL .. "?wait=true",
			Method = "POST",
			Headers = { ["Content-Type"] = "application/json" },
			Body = HttpService:JSONEncode(webhookBody),
		})
		if success and response and response.Body then
			local decoded = HttpService:JSONDecode(response.Body)
			if decoded and decoded.id then st.WebhookStatsMessageId = decoded.id end
		end
	end
end

local function StartStatsWebhook()
	if st.WebhookStatsEnabled then return end
	st.WebhookStatsEnabled = true
	st.WebhookStatsMessageId = nil
	_statsWebhookLoop = task.spawn(function()
		while st.WebhookStatsEnabled do
			SendStatsWebhook()
			task.wait(15)
		end
	end)
end

local function StopStatsWebhook()
	st.WebhookStatsEnabled = false
	if _statsWebhookLoop then task.cancel(_statsWebhookLoop); _statsWebhookLoop = nil end
	st.WebhookStatsMessageId = nil
end

local function StartWebhook()
	if st.WebhookRunning then return end
	st.WebhookRunning = true
	local Notifications = PlayerGui:WaitForChild("Top"):WaitForChild("Notifications")
	_webhookConnection = Notifications.ChildAdded:Connect(function(child)
		if not st.WebhookRunning then return end
		task.wait(0.1)
		local label = child:FindFirstChild("Frame") and child.Frame:FindFirstChild("Label")
		if not label or not string.find(label.Text, "Caught") then return end
		local name, weight, mutation = parseNotif(child)
		if not name then return end
		local rarity = getFishRarity(name)
		if not rarity then return end
		if not next(st.WebhookRarity) or not has(st.WebhookRarity, rarity) then return end
		local display = mutation and (mutation .. " " .. name) or name
		WebhookSend(display, rarity, weight)
	end)
end

local function StopWebhook()
	st.WebhookRunning = false
	if _webhookConnection then _webhookConnection:Disconnect(); _webhookConnection = nil end
end

local function WebhookTest()
	if st.WebhookURL == "" then return end
	WebhookSend("Test Fish", "Legendary", "99 kg")
end

local function GetRealPing()
	local ok, ping = pcall(function()
		local net = Stats:FindFirstChild("Network")
		if net then
			local ss = net:FindFirstChild("ServerStatsItem")
			if ss then
				local dp = ss:FindFirstChild("Data Ping")
				if dp then return math.floor(dp:GetValue()) end
			end
		end
		return math.floor(LocalPlayer:GetNetworkPing() * 1000)
	end)
	return ok and ping or 0
end

local fpsHistory, lastFrameTime = {}, tick()
local function GetFPS()
	local now = tick()
	local dt = now - lastFrameTime
	lastFrameTime = now
	table.insert(fpsHistory, dt > 0 and (1 / dt) or 0)
	if #fpsHistory > 20 then table.remove(fpsHistory, 1) end
	local sum = 0
	for _, f in ipairs(fpsHistory) do sum = sum + f end
	return math.floor(math.clamp(sum / #fpsHistory, 0, 240))
end

local function ColorByRange(value, thresholds)
	for _, t in ipairs(thresholds) do if t[1](value) then return t[2] end end
	return Color3.fromRGB(255, 255, 255)
end

local pingColors = {
	{ function(v) return v <= 50 end, Color3.fromRGB(100, 255, 200) },
	{ function(v) return v <= 100 end, Color3.fromRGB(150, 200, 255) },
	{ function(v) return v <= 150 end, Color3.fromRGB(180, 140, 255) },
	{ function() return true end, Color3.fromRGB(255, 100, 150) },
}
local fpsColors = {
	{ function(v) return v >= 55 end, Color3.fromRGB(100, 255, 200) },
	{ function(v) return v >= 40 end, Color3.fromRGB(150, 200, 255) },
	{ function(v) return v >= 25 end, Color3.fromRGB(180, 140, 255) },
	{ function() return true end, Color3.fromRGB(255, 100, 150) },
}

local function MakeElement(class, props, parent)
	local obj = Instance.new(class)
	for k, v in pairs(props) do obj[k] = v end
	obj.Parent = parent
	return obj
end

local function CreateMonitorGUI()
	local useCoreGui = pcall(function() local t = Instance.new("ScreenGui"); t.Parent = CoreGui; t:Destroy() end)
	local gui = MakeElement("ScreenGui", { Name = "VoraHubMonitor_" .. math.random(1, 999999), ResetOnSpawn = false, ZIndexBehavior = Enum.ZIndexBehavior.Sibling, DisplayOrder = 2147483647, IgnoreGuiInset = true }, useCoreGui and CoreGui or PlayerGui)
	local container = MakeElement("Frame", { Name = "Container", Size = UDim2.new(0, 200, 0, 70), Position = UDim2.new(0, 250, 0, 100), BackgroundColor3 = Color3.fromRGB(20, 30, 50), BackgroundTransparency = 0.15, BorderSizePixel = 0, Active = true, ZIndex = 10000 }, gui)
	MakeElement("UICorner", { CornerRadius = UDim.new(0, 10) }, container)
	MakeElement("UIStroke", { Color = Color3.fromRGB(50, 150, 255), Thickness = 2, Transparency = 0.3 }, container)
	local header = MakeElement("Frame", { Name = "Header", Size = UDim2.new(1, 0, 0, 35), BackgroundTransparency = 1, ZIndex = 10001 }, container)
	MakeElement("ImageLabel", { Size = UDim2.new(0, 24, 0, 24), Position = UDim2.new(0, 8, 0, 5), BackgroundTransparency = 1, Image = "rbxassetid://112067161065104", ScaleType = Enum.ScaleType.Fit, ImageColor3 = Color3.fromRGB(100, 180, 255), ZIndex = 10002 }, header)
	MakeElement("TextLabel", { Size = UDim2.new(1, -40, 1, 0), Position = UDim2.new(0, 36, 0, 0), BackgroundTransparency = 1, Text = "VORAHUB PANEL", TextColor3 = Color3.fromRGB(100, 180, 255), TextSize = 13, Font = Enum.Font.GothamBold, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = 10002 }, header)
	MakeElement("Frame", { Size = UDim2.new(1, -16, 0, 1), Position = UDim2.new(0, 8, 0, 35), BackgroundColor3 = Color3.fromRGB(50, 150, 255), BackgroundTransparency = 0.5, BorderSizePixel = 0, ZIndex = 10001 }, container)
	local content = MakeElement("Frame", { Name = "Content", Size = UDim2.new(1, -16, 0, 25), Position = UDim2.new(0, 8, 0, 40), BackgroundTransparency = 1, ZIndex = 10001 }, container)
	local pingLabel = MakeElement("TextLabel", { Name = "PingLabel", Size = UDim2.new(0.5, -6, 0, 25), BackgroundTransparency = 1, Text = "Ping: 0 ms", TextColor3 = Color3.fromRGB(150, 200, 255), TextSize = 13, Font = Enum.Font.GothamBold, TextXAlignment = Enum.TextXAlignment.Center, ZIndex = 10002 }, content)
	MakeElement("Frame", { Size = UDim2.new(0, 1, 0, 25), Position = UDim2.new(0.5, 0, 0, 0), BackgroundColor3 = Color3.fromRGB(50, 150, 255), BackgroundTransparency = 0.5, BorderSizePixel = 0, ZIndex = 10001 }, content)
	local fpsLabel = MakeElement("TextLabel", { Name = "FPSLabel", Size = UDim2.new(0.5, -6, 0, 25), Position = UDim2.new(0.5, 6, 0, 0), BackgroundTransparency = 1, Text = "FPS: 60", TextColor3 = Color3.fromRGB(100, 255, 200), TextSize = 13, Font = Enum.Font.GothamBold, TextXAlignment = Enum.TextXAlignment.Center, ZIndex = 10002 }, content)
	local dragging, dragInput, dragStart, startPos = false, nil, nil, nil
	container.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging, dragStart, startPos = true, input.Position, container.Position
			input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
		end
	end)
	container.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then dragInput = input end end)
	UserInputService.InputChanged:Connect(function(input) if input == dragInput and dragging then local delta = input.Position - dragStart; container.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y) end end)
	return { GUI = gui, Ping = pingLabel, FPS = fpsLabel }
end

local function ShowMonitor()
	if st.Monitor then st.Monitor.GUI.Enabled = true; return end
	st.Monitor = CreateMonitorGUI()
	st.MonitorConns[1] = RunService.RenderStepped:Connect(function()
		if not st.Monitor or not st.Monitor.GUI.Parent then if st.MonitorConns[1] then st.MonitorConns[1]:Disconnect() end return end
		local fps = GetFPS(); st.Monitor.FPS.Text = "FPS: " .. fps; st.Monitor.FPS.TextColor3 = ColorByRange(fps, fpsColors)
	end)
	local lastPing = 0
	st.MonitorConns[2] = RunService.Heartbeat:Connect(function()
		if not st.Monitor or not st.Monitor.GUI.Parent then if st.MonitorConns[2] then st.MonitorConns[2]:Disconnect() end return end
		local now = tick()
		if now - lastPing >= 0.5 then local ping = GetRealPing(); st.Monitor.Ping.Text = "Ping: " .. ping .. " ms"; st.Monitor.Ping.TextColor3 = ColorByRange(ping, pingColors); lastPing = now end
	end)
end

local function DestroyMonitor()
	for _, conn in pairs(st.MonitorConns) do if conn then conn:Disconnect() end end
	st.MonitorConns = {}
	if st.Monitor then st.Monitor.GUI:Destroy(); st.Monitor = nil end
	fpsHistory = {}
end

local function GetRarityColor(rarityName)
	local info = RarityModule[rarityName]
	return (info and info.color) or Color3.fromRGB(255, 255, 255)
end

local function ShouldShowESP(fishData)
	local hasR = next(st.ESPFilterRarity)
	local hasF = next(st.ESPFilterFish)
	local hasM = next(st.ESPFilterMutation)
	if not hasR and not hasF and not hasM then return true end
	local rOk, fOk, mOk = not hasR, not hasF, not hasM
	if hasR then local r = getFishRarity(fishData.name); if r and has(st.ESPFilterRarity, r) then rOk = true end end
	if hasF then if has(st.ESPFilterFish, fishData.name) then fOk = true end end
	if hasM then for _, m in ipairs(fishData.mutations or {}) do if has(st.ESPFilterMutation, m) then mOk = true; break end end end
	return rOk and fOk and mOk
end

local function CreateESPBillboard(fishId, fishData, parent)
	local rarity = getFishRarity(fishData.name) or "Unknown"
	local rc = GetRarityColor(rarity)
	local muts = fishData.mutations
	local mutText = (muts and #muts > 0) and table.concat(muts, ", ") or ""
	local bb = Instance.new("BillboardGui")
	bb.Name = "VoraESP_" .. fishId; bb.AlwaysOnTop = true; bb.Size = UDim2.new(0, 200, 0, 60); bb.StudsOffset = Vector3.new(0, 3, 0); bb.LightInfluence = 0; bb.MaxDistance = 5000; bb.ResetOnSpawn = false
	local mf = Instance.new("Frame"); mf.Name = "Main"; mf.Size = UDim2.new(1, 0, 1, 0); mf.BackgroundColor3 = Color3.fromRGB(10, 10, 20); mf.BackgroundTransparency = 0.35; mf.BorderSizePixel = 0; mf.Parent = bb
	Instance.new("UICorner", mf).CornerRadius = UDim.new(0, 6)
	local s = Instance.new("UIStroke"); s.Color = rc; s.Thickness = 1.5; s.Transparency = 0.3; s.Parent = mf
	local p = Instance.new("UIPadding"); p.PaddingLeft = UDim.new(0, 6); p.PaddingRight = UDim.new(0, 6); p.PaddingTop = UDim.new(0, 3); p.PaddingBottom = UDim.new(0, 3); p.Parent = mf
	local l = Instance.new("UIListLayout"); l.SortOrder = Enum.SortOrder.LayoutOrder; l.HorizontalAlignment = Enum.HorizontalAlignment.Center; l.Padding = UDim.new(0, 1); l.Parent = mf
	local nl = Instance.new("TextLabel"); nl.Name = "FishName"; nl.Size = UDim2.new(1, 0, 0, 16); nl.BackgroundTransparency = 1; nl.Text = fishData.name; nl.TextColor3 = rc; nl.TextSize = 13; nl.Font = Enum.Font.GothamBold; nl.TextXAlignment = Enum.TextXAlignment.Center; nl.LayoutOrder = 1; nl.Parent = mf
	local rl = Instance.new("TextLabel"); rl.Name = "Rarity"; rl.Size = UDim2.new(1, 0, 0, 13); rl.BackgroundTransparency = 1; rl.Text = rarity; rl.TextColor3 = rc; rl.TextSize = 11; rl.Font = Enum.Font.GothamMedium; rl.TextXAlignment = Enum.TextXAlignment.Center; rl.TextTransparency = 0.2; rl.LayoutOrder = 2; rl.Parent = mf
	if mutText ~= "" then
		local ml = Instance.new("TextLabel"); ml.Name = "Mutation"; ml.Size = UDim2.new(1, 0, 0, 12); ml.BackgroundTransparency = 1; ml.Text = mutText; ml.TextColor3 = Color3.fromRGB(255, 200, 100); ml.TextSize = 10; ml.Font = Enum.Font.GothamMedium; ml.TextXAlignment = Enum.TextXAlignment.Center; ml.LayoutOrder = 3; ml.Parent = mf
		bb.Size = UDim2.new(0, 200, 0, 72)
	end
	local dl = Instance.new("TextLabel"); dl.Name = "Distance"; dl.Size = UDim2.new(1, 0, 0, 13); dl.BackgroundTransparency = 1; dl.Text = "0m"; dl.TextColor3 = Color3.fromRGB(180, 180, 200); dl.TextSize = 11; dl.Font = Enum.Font.GothamMedium; dl.TextXAlignment = Enum.TextXAlignment.Center; dl.TextTransparency = 0.15; dl.LayoutOrder = 4; dl.Parent = mf
	bb.Parent = parent
	return bb
end

local function StartESP()
	if st.ESPEnabled then return end
	st.ESPEnabled = true
	local espHolder = Instance.new("Folder"); espHolder.Name = "VoraESPHolder"
	local useCG = pcall(function() local t = Instance.new("ScreenGui"); t.Parent = CoreGui; t:Destroy() end)
	espHolder.Parent = useCG and CoreGui or PlayerGui

	local function getESPFishList()
		local result = {}
		local cacheHasData = false
		if FishController and FishController.fish_cache then
			for _ in pairs(FishController.fish_cache) do cacheHasData = true; break end
		end
		if cacheHasData then
			for id, f in pairs(FishController.fish_cache) do
				if not f.dead and f.health > 0 then
					result[id] = f
				end
			end
		end
		local fishClient = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Fish") and workspace.Game.Fish:FindFirstChild("client")
		if fishClient then
			for _, fishModel in ipairs(fishClient:GetChildren()) do
				if not result[fishModel.Name] then
					local info = GetFishInfoFromModel(fishModel)
					if info then
						result[fishModel.Name] = { name = info.name, mutations = info.mutations, cframe = info.cframe, dead = false, health = 1 }
					end
				end
			end
		end
		return result
	end

	st.ESPConnection = RunService.RenderStepped:Connect(function()
		if not st.ESPEnabled then return end
		local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		local pp = hrp and hrp.Position or Vector3.zero
		local active = {}
		local allFish = getESPFishList()
		for id, f in pairs(allFish) do
			if ShouldShowESP(f) then
				active[id] = true
				if not st.ESPBillboards[id] then
					local part = Instance.new("Part"); part.Name = "ESPAnchor_" .. id; part.Anchored = true; part.CanCollide = false; part.Transparency = 1; part.Size = Vector3.new(0.1, 0.1, 0.1); part.CFrame = f.cframe; part.Parent = espHolder
					st.ESPBillboards[id] = { part = part, billboard = CreateESPBillboard(id, f, part) }
				end
				local data = st.ESPBillboards[id]
				if data and data.part then
					data.part.CFrame = f.cframe
					local dist = math.floor((f.cframe.Position - pp).Magnitude)
					local dl = data.billboard:FindFirstChild("Main") and data.billboard.Main:FindFirstChild("Distance")
					if dl then
						dl.Text = dist .. "m"
						dl.TextColor3 = dist <= 25 and Color3.fromRGB(100, 255, 150) or dist <= 75 and Color3.fromRGB(255, 255, 100) or Color3.fromRGB(255, 120, 120)
					end
				end
			end
		end
		for id, data in pairs(st.ESPBillboards) do
			if not active[id] then
				if data.billboard then data.billboard:Destroy() end
				if data.part then data.part:Destroy() end
				st.ESPBillboards[id] = nil
			end
		end
	end)
end

local function StopESP()
	st.ESPEnabled = false
	if st.ESPConnection then st.ESPConnection:Disconnect(); st.ESPConnection = nil end
	for _, data in pairs(st.ESPBillboards) do if data.billboard then data.billboard:Destroy() end; if data.part then data.part:Destroy() end end
	st.ESPBillboards = {}
	local holder = CoreGui:FindFirstChild("VoraESPHolder") or (PlayerGui and PlayerGui:FindFirstChild("VoraESPHolder"))
	if holder then holder:Destroy() end
end

local _savedLighting = {}
local _lowGfxConnection = nil

local function ApplyLowGraphics()
	local lighting = game:GetService("Lighting")
	_savedLighting.Brightness = lighting.Brightness; _savedLighting.GlobalShadows = lighting.GlobalShadows; _savedLighting.FogEnd = lighting.FogEnd
	_savedLighting.EnvironmentDiffuseScale = lighting.EnvironmentDiffuseScale; _savedLighting.EnvironmentSpecularScale = lighting.EnvironmentSpecularScale
	settings().Rendering.QualityLevel = 1; lighting.GlobalShadows = false; lighting.FogEnd = 100000; lighting.EnvironmentDiffuseScale = 0; lighting.EnvironmentSpecularScale = 0
	_savedLighting.PostEffects = {}
	for _, effect in ipairs(lighting:GetChildren()) do
		if effect:IsA("BloomEffect") or effect:IsA("BlurEffect") or effect:IsA("DepthOfFieldEffect") or effect:IsA("SunRaysEffect") or effect:IsA("ColorCorrectionEffect") then
			_savedLighting.PostEffects[effect] = effect.Enabled; effect.Enabled = false
		end
	end
	local terrain = workspace:FindFirstChildOfClass("Terrain")
	if terrain then
		_savedLighting.WaterWaveSize = terrain.WaterWaveSize; _savedLighting.WaterWaveSpeed = terrain.WaterWaveSpeed
		_savedLighting.WaterReflectance = terrain.WaterReflectance; _savedLighting.WaterTransparency = terrain.WaterTransparency
		terrain.WaterWaveSize = 0; terrain.WaterWaveSpeed = 0; terrain.WaterReflectance = 0; terrain.WaterTransparency = 0; terrain.Decoration = false
	end
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
			if obj:GetAttribute("_voraOrigEnabled") == nil then obj:SetAttribute("_voraOrigEnabled", obj.Enabled) end; obj.Enabled = false
		end
		if obj:IsA("Decal") or obj:IsA("Texture") then
			if obj:GetAttribute("_voraOrigTransparency") == nil then obj:SetAttribute("_voraOrigTransparency", obj.Transparency) end; obj.Transparency = 1
		end
		if obj:IsA("MeshPart") then obj.RenderFidelity = Enum.RenderFidelity.Performance end
	end
	_lowGfxConnection = workspace.DescendantAdded:Connect(function(obj)
		if not st.LowGraphics then return end
		task.defer(function()
			if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then obj:SetAttribute("_voraOrigEnabled", obj.Enabled); obj.Enabled = false end
			if obj:IsA("Decal") or obj:IsA("Texture") then obj:SetAttribute("_voraOrigTransparency", obj.Transparency); obj.Transparency = 1 end
			if obj:IsA("MeshPart") then obj.RenderFidelity = Enum.RenderFidelity.Performance end
		end)
	end)
end

local function RestoreGraphics()
	local lighting = game:GetService("Lighting")
	settings().Rendering.QualityLevel = 21
	if _savedLighting.GlobalShadows ~= nil then lighting.GlobalShadows = _savedLighting.GlobalShadows end
	if _savedLighting.FogEnd then lighting.FogEnd = _savedLighting.FogEnd end
	if _savedLighting.EnvironmentDiffuseScale then lighting.EnvironmentDiffuseScale = _savedLighting.EnvironmentDiffuseScale end
	if _savedLighting.EnvironmentSpecularScale then lighting.EnvironmentSpecularScale = _savedLighting.EnvironmentSpecularScale end
	if _savedLighting.PostEffects then for effect, enabled in pairs(_savedLighting.PostEffects) do if effect and effect.Parent then effect.Enabled = enabled end end end
	local terrain = workspace:FindFirstChildOfClass("Terrain")
	if terrain then
		if _savedLighting.WaterWaveSize then terrain.WaterWaveSize = _savedLighting.WaterWaveSize end
		if _savedLighting.WaterWaveSpeed then terrain.WaterWaveSpeed = _savedLighting.WaterWaveSpeed end
		if _savedLighting.WaterReflectance then terrain.WaterReflectance = _savedLighting.WaterReflectance end
		if _savedLighting.WaterTransparency then terrain.WaterTransparency = _savedLighting.WaterTransparency end
		terrain.Decoration = true
	end
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then local orig = obj:GetAttribute("_voraOrigEnabled"); if orig ~= nil then obj.Enabled = orig end end
		if obj:IsA("Decal") or obj:IsA("Texture") then local orig = obj:GetAttribute("_voraOrigTransparency"); if orig ~= nil then obj.Transparency = orig end end
		if obj:IsA("MeshPart") then obj.RenderFidelity = Enum.RenderFidelity.Automatic end
	end
	if _lowGfxConnection then _lowGfxConnection:Disconnect(); _lowGfxConnection = nil end
	_savedLighting = {}
end

local _extremeGfxConnection = nil
local function IsPlayerOrFish(obj)
	local char = LocalPlayer.Character
	if char and (obj == char or obj:IsDescendantOf(char)) then return true end
	for _, p in ipairs(Players:GetPlayers()) do local c = p.Character; if c and (obj == c or obj:IsDescendantOf(c)) then return true end end
	local fishClient = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Fish") and workspace.Game.Fish:FindFirstChild("client")
	if fishClient and (obj == fishClient or obj:IsDescendantOf(fishClient)) then return true end
	return false
end
local function IsGUIRelated(obj)
	if obj:IsDescendantOf(CoreGui) then return true end
	if PlayerGui and obj:IsDescendantOf(PlayerGui) then return true end
	local parent = obj.Parent
	while parent do if parent:IsA("ScreenGui") or parent:IsA("BillboardGui") or parent:IsA("SurfaceGui") then return true end; parent = parent.Parent end
	return false
end
local function NukePart(obj)
	if obj:GetAttribute("_voraExtremeMat") == nil then obj:SetAttribute("_voraExtremeMat", obj.Material.Name); obj:SetAttribute("_voraExtremeColor", obj.Color:ToHex()); if obj:IsA("BasePart") then obj:SetAttribute("_voraExtremeCastShadow", obj.CastShadow) end end
	obj.Material = Enum.Material.SmoothPlastic; obj.CastShadow = false
	if obj:IsA("MeshPart") then obj.RenderFidelity = Enum.RenderFidelity.Performance; if obj.TextureID and obj:GetAttribute("_voraExtremeTexID") == nil then obj:SetAttribute("_voraExtremeTexID", obj.TextureID) end; obj.TextureID = "" end
	if obj:IsA("UnionOperation") then obj.RenderFidelity = Enum.RenderFidelity.Performance end
end
local function NukeEffect(obj)
	if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then if obj:GetAttribute("_voraExtremeEnabled") == nil then obj:SetAttribute("_voraExtremeEnabled", obj.Enabled) end; obj.Enabled = false; return end
	if obj:IsA("Decal") or obj:IsA("Texture") then if obj:GetAttribute("_voraExtremeTransp") == nil then obj:SetAttribute("_voraExtremeTransp", obj.Transparency) end; obj.Transparency = 1; return end
	if obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then if obj:GetAttribute("_voraExtremeEnabled") == nil then obj:SetAttribute("_voraExtremeEnabled", obj.Enabled) end; obj.Enabled = false; return end
	if obj:IsA("Sound") then if obj:GetAttribute("_voraExtremeVol") == nil then obj:SetAttribute("_voraExtremeVol", obj.Volume) end; obj.Volume = 0 end
end

local function ApplyExtremeGraphics()
	local lighting = game:GetService("Lighting")
	if not next(_savedLighting) then _savedLighting.Brightness = lighting.Brightness; _savedLighting.GlobalShadows = lighting.GlobalShadows; _savedLighting.FogEnd = lighting.FogEnd; _savedLighting.EnvironmentDiffuseScale = lighting.EnvironmentDiffuseScale; _savedLighting.EnvironmentSpecularScale = lighting.EnvironmentSpecularScale end
	settings().Rendering.QualityLevel = 1; lighting.GlobalShadows = false; lighting.FogEnd = 100000; lighting.EnvironmentDiffuseScale = 0; lighting.EnvironmentSpecularScale = 0; lighting.Brightness = 2
	if not _savedLighting.PostEffects then _savedLighting.PostEffects = {} end
	for _, effect in ipairs(lighting:GetChildren()) do if effect:IsA("PostEffect") then if not _savedLighting.PostEffects[effect] then _savedLighting.PostEffects[effect] = effect.Enabled end; effect.Enabled = false end end
	local terrain = workspace:FindFirstChildOfClass("Terrain")
	if terrain then
		if not _savedLighting.WaterWaveSize then _savedLighting.WaterWaveSize = terrain.WaterWaveSize; _savedLighting.WaterWaveSpeed = terrain.WaterWaveSpeed; _savedLighting.WaterReflectance = terrain.WaterReflectance; _savedLighting.WaterTransparency = terrain.WaterTransparency end
		terrain.WaterWaveSize = 0; terrain.WaterWaveSpeed = 0; terrain.WaterReflectance = 0; terrain.WaterTransparency = 0; terrain.Decoration = false
	end
	for _, obj in ipairs(workspace:GetDescendants()) do if IsPlayerOrFish(obj) or IsGUIRelated(obj) then continue end; if obj:IsA("BasePart") then NukePart(obj) end; NukeEffect(obj) end
	_extremeGfxConnection = workspace.DescendantAdded:Connect(function(obj) if not st.ExtremeGraphics then return end; task.defer(function() if IsPlayerOrFish(obj) or IsGUIRelated(obj) then return end; if obj:IsA("BasePart") then NukePart(obj) end; NukeEffect(obj) end) end)
end

local function RestoreExtremeGraphics()
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			local mat = obj:GetAttribute("_voraExtremeMat"); if mat then pcall(function() obj.Material = Enum.Material[mat] end) end
			local col = obj:GetAttribute("_voraExtremeColor"); if col then pcall(function() obj.Color = Color3.fromHex(col) end) end
			local cs = obj:GetAttribute("_voraExtremeCastShadow"); if cs ~= nil then obj.CastShadow = cs end
			if obj:IsA("MeshPart") then obj.RenderFidelity = Enum.RenderFidelity.Automatic; local tid = obj:GetAttribute("_voraExtremeTexID"); if tid then obj.TextureID = tid end end
			if obj:IsA("UnionOperation") then obj.RenderFidelity = Enum.RenderFidelity.Automatic end
		end
		if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") or obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then local orig = obj:GetAttribute("_voraExtremeEnabled"); if orig ~= nil then obj.Enabled = orig end end
		if obj:IsA("Decal") or obj:IsA("Texture") then local orig = obj:GetAttribute("_voraExtremeTransp"); if orig ~= nil then obj.Transparency = orig end end
		if obj:IsA("Sound") then local orig = obj:GetAttribute("_voraExtremeVol"); if orig ~= nil then obj.Volume = orig end end
	end
	RestoreGraphics()
	if _extremeGfxConnection then _extremeGfxConnection:Disconnect(); _extremeGfxConnection = nil end
end

local function GetNearestChest()
	local chestsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Chests")
	if not chestsFolder then return nil end
	local tierFolder = chestsFolder:FindFirstChild(st.SelectedTier)
	if not tierFolder then return nil end
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end
	local nearest, nearestDist, nearestId, nearestPart = nil, math.huge, nil, nil
	for _, chestContainer in ipairs(tierFolder:GetChildren()) do
		local chestId = st.SelectedTier .. "_" .. chestContainer.Name
		if st.ChestBlacklist[chestId] then continue end
		local chestFolder = chestContainer:FindFirstChild("Chest")
		if not chestFolder then st.ChestBlacklist[chestId] = true; continue end
		local main = chestFolder:FindFirstChild("Main")
		if not main then st.ChestBlacklist[chestId] = true; continue end
		local highlight = main:FindFirstChild("Highlight")
		if highlight then st.ChestBlacklist[chestId] = true; continue end
		local rootPart = main:FindFirstChild("RootPart")
		if not rootPart or not rootPart:IsA("BasePart") then
			rootPart = chestFolder:FindFirstChild("RootPart")
			if not rootPart or not rootPart:IsA("BasePart") then st.ChestBlacklist[chestId] = true; continue end
		end
		local dist = (hrp.Position - rootPart.Position).Magnitude
		if dist < nearestDist then
			nearest = chestContainer; nearestDist = dist; nearestId = chestContainer.Name; nearestPart = rootPart
		end
	end
	return nearestPart, nearestId
end

local function StartAutoTreasure(notifyFunc)
	if st.AutoTreasure then return end
	st.AutoTreasure = true
	st.TreasureRunning = false
	st.ChestsFarmed = 0
	if notifyFunc then notifyFunc({ Title = "Treasure Hunter", Content = "Started - " .. st.SelectedTier, Duration = 2 }) end
	task.spawn(function()
		while st.AutoTreasure do
			if st.TreasureRunning then task.wait(0.1); continue end
			local chestPart, chestId = GetNearestChest()
			if chestPart and chestId then
				st.TreasureRunning = true
				local targetCFrame = chestPart.CFrame * CFrame.new(0, 5, 0)
				local success = TweenToAndWait(targetCFrame, 500)
				if success then
					task.wait(0.5)
					local unlockSuccess = pcall(function() Remotes.UnlockChest:InvokeServer(st.SelectedTier, chestId) end)
					local blacklistId = st.SelectedTier .. "_" .. chestId
					st.ChestBlacklist[blacklistId] = true
					if unlockSuccess then
						st.ChestsFarmed = st.ChestsFarmed + 1
						if notifyFunc then notifyFunc({ Title = "Chest Unlocked", Content = "#" .. st.ChestsFarmed .. " - " .. chestId, Duration = 2 }) end
					end
					task.wait(1)
				else
					local blacklistId = st.SelectedTier .. "_" .. chestId
					st.ChestBlacklist[blacklistId] = true
				end
				st.TreasureRunning = false
				task.wait(0.2)
			else
				if notifyFunc then notifyFunc({ Title = "Treasure Hunter", Content = "No chests. Total: " .. st.ChestsFarmed, Duration = 4 }) end
				task.wait(3)
			end
		end
		if notifyFunc then notifyFunc({ Title = "Treasure Hunter", Content = "Stopped. Total: " .. st.ChestsFarmed, Duration = 3 }) end
	end)
end

local function StopAutoTreasure()
	st.AutoTreasure = false
	st.TreasureRunning = false
	CancelCurrentTween()
end

local _originalOverheadText = nil
local _hideIdentifierConn = nil

local function GetOverheadDisplay()
	local debris = workspace:FindFirstChild("debris")
	if not debris then return nil end
	local folder = debris:FindFirstChild(LocalPlayer.Name)
	if not folder then return nil end
	local hrp = folder:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end
	local attachment = hrp:FindFirstChild("OverheadAttachment")
	if not attachment then return nil end
	local overhead = attachment:FindFirstChild("playerOverhead")
	if not overhead then return nil end
	return overhead:FindFirstChild("Display")
end

local function GetCurrentOverheadInfo()
	local display = GetOverheadDisplay()
	if not display then return nil, nil end
	local text = display.Text
	local level = text:match("%[Lv%. (%d+)%]")
	local name = text:match("</font>%s*(.+)$")
	local color = text:match("<font color='(#%w+)'>")
	return name, level, color
end

local function ApplyHideIdentifier()
	local display = GetOverheadDisplay()
	if not display then return end
	if not _originalOverheadText then _originalOverheadText = display.Text end
	local _, _, color = GetCurrentOverheadInfo()
	color = color or "#FFF0C8"
	local fakeName = st.FakeName ~= "" and st.FakeName or (LocalPlayer.DisplayName or LocalPlayer.Name)
	local fakeLevel = st.FakeLevel ~= "" and st.FakeLevel or "1"
	display.Text = "<font color='" .. color .. "'>[Lv. " .. fakeLevel .. "]</font> " .. fakeName
end

local function RestoreOverhead()
	if _originalOverheadText then
		local display = GetOverheadDisplay()
		if display then display.Text = _originalOverheadText end
		_originalOverheadText = nil
	end
end

local function StartHideIdentifier()
	st.HideIdentifier = true
	ApplyHideIdentifier()
	_hideIdentifierConn = RunService.Heartbeat:Connect(function()
		if not st.HideIdentifier then return end
		local display = GetOverheadDisplay()
		if not display then return end
		local color = nil
		if _originalOverheadText then color = _originalOverheadText:match("<font color='(#%w+)'>") end
		color = color or "#FFF0C8"
		local fakeName = st.FakeName ~= "" and st.FakeName or (LocalPlayer.DisplayName or LocalPlayer.Name)
		local fakeLevel = st.FakeLevel ~= "" and st.FakeLevel or "1"
		local expected = "<font color='" .. color .. "'>[Lv. " .. fakeLevel .. "]</font> " .. fakeName
		if display.Text ~= expected then
			if not _originalOverheadText then _originalOverheadText = display.Text end
			display.Text = expected
		end
	end)
end

local function StopHideIdentifier()
	st.HideIdentifier = false
	if _hideIdentifierConn then _hideIdentifierConn:Disconnect(); _hideIdentifierConn = nil end
	RestoreOverhead()
end

local Window = VoraLib:CreateWindow({
	Name = "VoraHUB | Abyss Fixed",
	Intro = true,
	Theme = {
		Background = Color3.fromRGB(10, 12, 25),
		Accent = Color3.fromRGB(138, 43, 226)
	}
})

local Tabs = {
	Home = Window:CreateTab({ Name = "Home", Icon = "star" }),
	Main = Window:CreateTab({ Name = "Main", Icon = "rod" }),
	Farm = Window:CreateTab({ Name = "Auto Farm", Icon = "rod" }),
	Backpack = Window:CreateTab({ Name = "Backpack", Icon = "bag" }),
	Shop = Window:CreateTab({ Name = "Shop", Icon = "shop" }),
	Webhook = Window:CreateTab({ Name = "Webhook", Icon = "web" }),
}

Tabs.Home:CreateSection({ Name = "Information" })
Tabs.Home:CreateParagraph({
	Title = "Changelog | v0.1.7-fixed",
	Content = table.concat({
		"[FIX] Anti-kick: Always noclip + no collision",
		"[FIX] Auto farm uses catching attribute check",
		"[FIX] CatchingMinigame override restored",
		"[FIX] Removed CaughtSignal notification dependency",
		"",
		"Discord: discord.gg/vorahub",
	}, "\n")
})

Tabs.Home:CreateButton({
	Name = "Join our Discord",
	Callback = function()
		if setclipboard then
			setclipboard("https://discord.gg/vorahub")
			Window:Notify({ Title = "Discord", Content = "Discord link copied!", Duration = 3 })
		end
	end
})

Tabs.Main:CreateSection({ Name = "Helper Features" })
Tabs.Main:CreateToggle({
	Name = "Show Ping / FPS Monitor",
	SubText = "Draggable overlay showing real-time Ping & FPS.",
	Default = false,
	Callback = function(v) if v then ShowMonitor() else DestroyMonitor() end end
})

Tabs.Main:CreateToggle({
	Name = "Auto Equip Gun",
	SubText = "Automatically equip gun if not equipped.",
	Default = false,
	Callback = function(v)
		st.AutoEquipGun = v
		if not v then return end
		task.spawn(function()
			while st.AutoEquipGun do
				local debris = workspace:FindFirstChild("debris")
				local folder = debris and debris:FindFirstChild(LocalPlayer.Name)
				local hasTool = false
				if folder then
					for _, child in ipairs(folder:GetChildren()) do
						if child:IsA("Tool") then hasTool = true; break end
					end
				end
				if not hasTool then pcall(function() Remotes.Equip:InvokeServer("1") end) end
				task.wait(0.5)
			end
		end)
	end
})

Tabs.Main:CreateToggle({
	Name = "Always Noclip",
	SubText = "Keep noclip enabled at all times to prevent kicks.",
	Default = true,
	Callback = function(v) st.NoclipEnabled = v end
})

Tabs.Main:CreateSection({ Name = "Equip Items" })
Tabs.Main:CreateDropdown({
	Name = "Select Gun to Equip",
	Items = GunList,
	Default = GunList[1],
	Callback = function(v) st.EquipGunName = v end
})

Tabs.Main:CreateButton({
	Name = "Equip Selected Gun",
	Callback = function()
		if st.EquipGunName then pcall(function() Remotes.EquipItem:InvokeServer("guns", st.EquipGunName) end) end
	end
})

Tabs.Main:CreateDropdown({
	Name = "Select Tube to Equip",
	Items = TubeList,
	Default = TubeList[1],
	Callback = function(v) st.EquipTubeName = v end
})

Tabs.Main:CreateButton({
	Name = "Equip Selected Tube",
	Callback = function()
		if st.EquipTubeName then pcall(function() Remotes.EquipItem:InvokeServer("tubes", st.EquipTubeName) end) end
	end
})

Tabs.Main:CreateSection({ Name = "Hide Identifier" })
Tabs.Main:CreateInput({
	Name = "Fake Name",
	Placeholder = "Enter fake name...",
	Default = "",
	Callback = function(v) st.FakeName = v; if st.HideIdentifier then ApplyHideIdentifier() end end
})

Tabs.Main:CreateInput({
	Name = "Fake Level",
	Placeholder = "Enter fake level...",
	Default = "",
	Callback = function(v) st.FakeLevel = v; if st.HideIdentifier then ApplyHideIdentifier() end end
})

Tabs.Main:CreateToggle({
	Name = "Enable Hide Identifier",
	SubText = "Change your overhead display name and level.",
	Default = false,
	Callback = function(v) if v then StartHideIdentifier() else StopHideIdentifier() end end
})

Tabs.Main:CreateSection({ Name = "Fish ESP" })
Tabs.Main:CreateMultiDropdown({
	Name = "ESP Filter by Rarity",
	Items = RarityList,
	Default = {},
	Callback = function(v) st.ESPFilterRarity = v end
})

Tabs.Main:CreateMultiDropdown({
	Name = "ESP Filter by Fish",
	Items = FishList,
	Default = {},
	Callback = function(v) st.ESPFilterFish = v end
})

Tabs.Main:CreateMultiDropdown({
	Name = "ESP Filter by Mutation",
	Items = MutationList,
	Default = {},
	Callback = function(v) st.ESPFilterMutation = v end
})

Tabs.Main:CreateToggle({
	Name = "Enable Fish ESP",
	SubText = "Show fish name, rarity and distance above fish.",
	Default = false,
	Callback = function(v) if v then StartESP() else StopESP() end end
})

Tabs.Main:CreateSection({ Name = "Auto Treasure" })
Tabs.Main:CreateDropdown({
	Name = "Select Tier",
	Items = { "Tier 1", "Tier 2", "Tier 3" },
	Default = "Tier 1",
	Callback = function(v) st.SelectedTier = v; st.ChestBlacklist = {} end
})

Tabs.Main:CreateButton({
	Name = "Reset Blacklist",
	Callback = function()
		local count = 0
		for _ in pairs(st.ChestBlacklist) do count = count + 1 end
		st.ChestBlacklist = {}
		Window:Notify({ Title = "Treasure Hunter", Content = "Cleared " .. count .. " chests", Duration = 2 })
	end
})

Tabs.Main:CreateToggle({
	Name = "Auto Treasure Hunt",
	SubText = "Automatically farm treasure chests in selected tier.",
	Default = false,
	Callback = function(v)
		if v then StartAutoTreasure(function(data) Window:Notify(data) end)
		else StopAutoTreasure() end
	end
})

Tabs.Main:CreateSection({ Name = "Improvement" })
Tabs.Main:CreateToggle({
	Name = "Low Graphics",
	SubText = "Set all graphics to lowest.",
	Default = false,
	Callback = function(v)
		st.LowGraphics = v
		if v then
			if st.ExtremeGraphics then st.ExtremeGraphics = false; RestoreExtremeGraphics() end
			ApplyLowGraphics()
		else RestoreGraphics() end
	end
})

Tabs.Main:CreateToggle({
	Name = "Extreme Low Graphics",
	SubText = "Strip textures, materials, lights, sounds.",
	Default = false,
	Callback = function(v)
		st.ExtremeGraphics = v
		if v then
			if st.LowGraphics then st.LowGraphics = false; RestoreGraphics() end
			ApplyExtremeGraphics()
		else RestoreExtremeGraphics() end
	end
})

Tabs.Farm:CreateSection({ Name = "Auto Farm" })

Tabs.Farm:CreateMultiDropdown({
	Name = "Select Rarity to Catch",
	Items = RarityList,
	Default = {},
	Callback = function(v) st.SelectRarity = v end
})

Tabs.Farm:CreateMultiDropdown({
	Name = "1st Priority Fish",
	Items = FishList,
	Default = {},
	Callback = function(v) st.Priority1 = v end
})

Tabs.Farm:CreateMultiDropdown({
	Name = "2nd Priority Fish",
	Items = FishList,
	Default = {},
	Callback = function(v) st.Priority2 = v end
})

Tabs.Farm:CreateMultiDropdown({
	Name = "3rd Priority Fish",
	Items = FishList,
	Default = {},
	Callback = function(v) st.Priority3 = v end
})

Tabs.Farm:CreateMultiDropdown({
	Name = "Mutation to Catch",
	Items = MutationList,
	Default = {},
	Callback = function(v) st.SelectedMutations = v end
})

Tabs.Farm:CreateDropdown({
	Name = "Farm Location",
	Items = { "None", "Ancient Sands", "Forgotten Deep", "Spirit Roots" },
	Default = "None",
	Callback = function(v)
		if v == "None" then st.SelectedFarm = nil else st.SelectedFarm = v end
	end
})

Tabs.Farm:CreateSlider({
	Name = "Speed Delay (seconds)",
	Placeholder = "0.3",
	Default = "0.3",
	Callback = function(v)
		local n = tonumber(v)
		if n then st.TweenTime = n end
	end
})

Tabs.Farm:CreateSlider({
	Name = "Catch Range",
	Min = 1,
	Max = 100,
	Default = 25,
	Callback = function(v)
		st.MaxRange = v
	end
})

Tabs.Farm:CreateToggle({
	Name = "Instant Catch",
	SubText = "Instantly complete the catching minigame.",
	Default = false,
	Callback = function(v) st.InstantCatch = v end
})

Tabs.Farm:CreateToggle({
	Name = "Start Auto Farm",
	SubText = "",
	Default = false,
	Callback = function(v) if v then StartAutoFarm() else StopAutoFarm() end end
})

Tabs.Farm:CreateToggle({
	Name = "Auto Refill Oxygen",
	Default = false,
	Callback = function(v) st.AutoRefillOxygen = v end
})

Tabs.Farm:CreateSection({ Name = "Auto Sell" })

Tabs.Farm:CreateInput({
	Name = "Sell At (number / % / max)",
	Placeholder = "90%",
	Default = "90%",
	Callback = function(v) st.SellAt = string.lower(v) end
})

Tabs.Farm:CreateToggle({
	Name = "Auto Sell",
	SubText = "Auto sell when weight reaches threshold.",
	Default = false,
	Callback = function(v) st.AutoSell = v end
})

Tabs.Farm:CreateSection({ Name = "Auto Respawn" })

Tabs.Farm:CreateToggle({
	Name = "Auto Respawn",
	SubText = "Automatically respawn when dead.",
	Default = false,
	Callback = function(state)
		st.AutoRespawn = state
		st.AutoRespawnToken = st.AutoRespawnToken + 1
		local token = st.AutoRespawnToken
		if not state then GuiService.SelectedObject = nil; return end
		task.spawn(function()
			while st.AutoRespawn and token == st.AutoRespawnToken do
				local deathGui = PlayerGui:FindFirstChild("DeathScreen")
				if deathGui and deathGui.Enabled then
					local btn = deathGui:FindFirstChild("Frame", true)
						and deathGui.Frame.Frame.Buttons.Respawn
						and deathGui.Frame.Frame.Buttons.Respawn:FindFirstChild("Button")
					if btn and btn.Visible then
						GuiService.SelectedObject = btn
						task.wait(0.05)
						if not st.AutoRespawn or token ~= st.AutoRespawnToken then break end
						VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
						task.wait(0.02)
						VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
					else
						GuiService.SelectedObject = nil
					end
				end
				task.wait(0.1)
			end
			if token == st.AutoRespawnToken then GuiService.SelectedObject = nil end
		end)
	end
})

Tabs.Backpack:CreateSection({ Name = "Favorite" })
Tabs.Backpack:CreateMultiDropdown({
	Name = "Select Rarity to Auto Favorite",
	Items = RarityList,
	Default = {},
	Callback = function(v) st.SelectFavRarity = v end
})

Tabs.Backpack:CreateMultiDropdown({
	Name = "Select Fish to Auto Favorite",
	Items = FishList,
	Default = {},
	Callback = function(v) st.SelectFish = v end
})

Tabs.Backpack:CreateMultiDropdown({
	Name = "Select Mutation to Auto Favorite",
	Items = MutationList,
	Default = {},
	Callback = function(v) st.SelectMutation = v end
})

Tabs.Backpack:CreateToggle({
	Name = "Strict Mode",
	SubText = "Only favorite fish that match ALL selected criteria.",
	Default = false,
	Callback = function(v) st.StrictMode = v end
})

Tabs.Backpack:CreateToggle({
	Name = "Auto Favorite",
	SubText = "Automatically favorite selected fish when caught.",
	Default = false,
	Callback = function(v) if v then StartFavorite() else StopFavorite() end end
})

Tabs.Backpack:CreateToggle({
	Name = "Unfavorite All Fish",
	SubText = "Automatically unfavorite all favorited fish.",
	Default = false,
	Callback = function(v) if v then UnfavoriteAll() else StopUnfavorite() end end
})

Tabs.Shop:CreateSection({ Name = "Buy Gun" })
Tabs.Shop:CreateDropdown({
	Name = "Select Gun",
	Items = GunList,
	Default = GunList[1],
	Callback = function(v) st.SelectedGun = v end
})

Tabs.Shop:CreateButton({
	Name = "Buy Selected Gun",
	Callback = function()
		if st.SelectedGun then pcall(function() Remotes.BuyItem:InvokeServer(st.SelectedGun, 1, "guns") end) end
	end
})

Tabs.Shop:CreateSection({ Name = "Buy Tubes" })
Tabs.Shop:CreateDropdown({
	Name = "Select Tube",
	Items = TubeList,
	Default = TubeList[1],
	Callback = function(v) st.SelectedTube = v end
})

Tabs.Shop:CreateButton({
	Name = "Buy Selected Tube",
	Callback = function()
		if st.SelectedTube then pcall(function() Remotes.BuyItem:InvokeServer(st.SelectedTube, 1, "tubes") end) end
	end
})

Tabs.Shop:CreateSection({ Name = "Reroll Features" })
Tabs.Shop:CreateButton({
	Name = "Auto Reroll Race",
	Callback = function() pcall(function() Remotes.Reroll:InvokeServer() end) end
})

Tabs.Webhook:CreateSection({ Name = "Fish Caught Webhook" })
Tabs.Webhook:CreateInput({
	Name = "Webhook URL",
	Placeholder = "https://discord.com/api/webhooks/...",
	Default = "",
	Callback = function(v) st.WebhookURL = v end
})

Tabs.Webhook:CreateMultiDropdown({
	Name = "Select Rarity to Send",
	Items = RarityList,
	Default = {},
	Callback = function(v) st.WebhookRarity = v end
})

Tabs.Webhook:CreateToggle({
	Name = "Enable Fish Caught Webhook",
	SubText = "Send webhook notification when catching selected rarity fish.",
	Default = false,
	Callback = function(v) if v then StartWebhook() else StopWebhook() end end
})

Tabs.Webhook:CreateButton({
	Name = "Test Fish Webhook",
	Callback = function()
		WebhookTest()
		Window:Notify({ Title = "Webhook", Content = "Webhook test sent!", Duration = 3 })
	end
})

Tabs.Webhook:CreateSection({ Name = "Player Stats Webhook" })
Tabs.Webhook:CreateInput({
	Name = "Stats Webhook URL",
	Placeholder = "https://discord.com/api/webhooks/...",
	Default = "",
	Callback = function(v) st.WebhookStatsURL = v end
})

Tabs.Webhook:CreateToggle({
	Name = "Enable Stats Webhook",
	SubText = "Auto-update player statistics every 15 seconds.",
	Default = false,
	Callback = function(v) if v then StartStatsWebhook() else StopStatsWebhook() end end
})

Tabs.Webhook:CreateButton({
	Name = "Test Stats Webhook",
	Callback = function()
		SendStatsWebhook()
		Window:Notify({ Title = "Stats Webhook", Content = "Stats webhook sent!", Duration = 3 })
	end
})

task.spawn(function()
	while true do
		local Camera = workspace.CurrentCamera
		if Camera then
			VirtualUser:Button2Down(Vector2.new(0, 0), Camera.CFrame)
			task.wait(1)
			VirtualUser:Button2Up(Vector2.new(0, 0), Camera.CFrame)
		end
		task.wait(300)
	end
end)

task.defer(function()
	task.wait(0.1)
	Window:Notify({
		Title = "Abyss",
		Content = "Script loaded successfully!",
		Duration = 5
	})
end)
